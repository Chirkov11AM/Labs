:figure-caption: Рисунок
:table-caption: Таблица
= Лабораторная №1 Думановский А.А. КЭ-413
:toc:
:toc-title: Оглавление:



== Задание

* Написать программу, которая моргает всеми 4 светодиодами, но без использования магии с GPIOA::ODR::ODR5::High::Set() и тому подобное; а только прямой доступ к памяти по адресам, только хардкор.
* Описать, как работает операция ИСКЛЮЧАЮЩЕЕ ИЛИ
* Описать как поменять значения переменных местами, без привлечения третьей переменной

== Работа с программой
Запустили необходимый файл, выбали необходимую плату.

image::image-2021-09-29-23-17-13-190.png[]

Выбрали необходиммый отладчик.

image::image-2021-09-29-23-18-28-635.png[]
Для начала создаем таймер.
Также необходимо указать оптимизатору чтобы он не "выкидывал" данную часть кода.

[source, c++]
int delay(int time)
{
 for (int i = 0; i < time; ++i)
 {
  asm volatile("");
 }
}

После включаем порты на которых находятся диоды и обозначаем их как выходы. Далее прописываем поочередное включение и выключение диодов. Смотрим каким регисторам они соответсвует и включаем их. При наличии единицы в регистре диод горит, при нулевом значении - не горит.

[source, c++]
for(int j=0;j<1000;++j)//поскольку не рекомендуется использовать бесконечный цикл
 {
   uint32_t* ptrPaODR = reinterpret_cast<uint32_t*>(0x40020014);
   uint32_t* ptrPCODR = reinterpret_cast<uint32_t*>(0x40020814);
   *ptrPaODR ^= static_cast<uint32_t>(1 << 5);//1<<5 = 0001000
   *ptrPCODR ^= static_cast<uint32_t>(1 << 9);
   *ptrPCODR ^= static_cast<uint32_t>(1 << 8);
   *ptrPCODR ^= static_cast<uint32_t>(1 << 5);
   delay(1000000);
   *ptrPCODR ^= static_cast<uint32_t>(1 << 5);
   *ptrPCODR ^= static_cast<uint32_t>(1 << 8);
   *ptrPCODR ^= static_cast<uint32_t>(1 << 9);
   *ptrPaODR ^= static_cast<uint32_t>(1 << 5);
   delay(1000000);

 }
return 0;

Результат:


image::video_2021-10-14_21-45-03.gif[]

=== Исключающее ИЛИ
Для влючения регистров используем функцию исключающего ИЛИ, которая выполняется с 2-мя битами (a и b). Результат выполнения операции исключающее ИЛИ равен 1, когда один из битов b или a равен 1. В остальных ситуациях результат применения оператора XOR равен 0. Т.е. если диод был выключен (значение на регистре 0) и мы подаем 1, то он загорается, если в регистре была 1 и мы подали 1 то зачение становится равным 0.

== Как поменять значения переменных местами, без привлечения третьей переменной
Существует несколько способ сделать это, один из наиболее простых это:
[source, c++]
a=2;
b=4;
b = a + b; // 4+2=6
a = b - a; // 6-2=4
b = b - a; // 6-4=2

Есть и такой способ через исключающее ИЛИ:
[source, c++]

             // X == a; Y == b
X = X XOR Y  // X == a XOR b;  Y == b
Y = X XOR Y  // X == a XOR b;  Y == b XOR (a XOR b)
X = X XOR Y  // X == (a XOR b) XOR b XOR (a XOR b);  Y == b XOR (a XOR b)

Поскольку XOR ассоциативен, мы можем перегруппировать полученные уравнения следующим образом:
[source, c++]
X == (a XOR a) XOR (b XOR b) XOR b
Y == (b XOR b) XOR a

Поскольку x XOR x == 0 и x XOR 0 == x , мы можем просто удалить все эти пары переменных XOR'ed с самими собой, и то, что осталось:
[source, c++]
X == b
Y == a